use std::{
    collections::HashMap,
    fs::File,
    io::{Read, Write},
    path::PathBuf,
    process::Command,
};

const HEADER: &str = r#"/*
############################
## DO NOT EDIT THIS FILE! ##
############################

Please only run `cargo run --bin typeshare` to update this file.
Types are automatically generated from structs annotated with `#[typeshare]`.
*/

/* eslint-disable */
"#;

pub fn main() {
    let dir = env!("CARGO_MANIFEST_DIR");

    let mapping: HashMap<&str, Vec<&str>> = HashMap::from_iter([
        // (
        //     "../frontend/src/types/rust.entity.d.ts",
        //     vec!["./crates/entity"],
        // ),
        ("../frontend/src/types/rust.api.ts", vec!["./crates/api"]),
    ]);

    for (output, inputs) in mapping {
        let output = PathBuf::from_iter([dir, output]);
        let inputs = inputs
            .iter()
            .map(|input| PathBuf::from_iter([dir, input]))
            .collect::<Vec<_>>();

        let run = Command::new("typeshare")
            .args(&inputs)
            .args(["--lang", "typescript", "--output-file"])
            .arg(&output)
            .current_dir(dir)
            .spawn()
            .unwrap()
            .wait()
            .unwrap();
        assert!(
            run.success(),
            "failed to run typeshare for {inputs:?} -> {output:?}: {run:?}"
        );

        let mut content = HEADER.as_bytes().to_vec();

        {
            let mut f = File::open(&output).expect("failed to open output file");
            f.read_to_end(&mut content)
                .expect("failed to read output file");
        }

        {
            let mut f = File::create(&output).expect("failed to create output file");
            f.write_all(content.as_slice())
                .expect("failed to write output file");
        }
    }
}
