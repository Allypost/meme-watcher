use std::{
    collections::HashMap,
    fs::File,
    io::{Read, Write},
    path::PathBuf,
    process::Command,
};

const HEADER: &str = r#"/*
############################
## DO NOT EDIT THIS FILE! ##
############################

Please only run `cargo run --bin typeshare` in the backend folder to update this file.
Types are automatically generated from structs annotated with `#[typeshare]`.
*/

/* eslint-disable */
"#;

pub fn main() {
    let base_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let base_out_dir = base_dir.join("../frontend/src/types/generated");
    std::fs::create_dir_all(&base_out_dir).unwrap();

    let mapping: HashMap<&str, Vec<&str>> = HashMap::from_iter([
        // (
        //     "backend/entity.d.ts",
        //     vec!["./crates/entity"],
        // ),
        ("backend/api.ts", vec!["./crates/api"]),
    ]);

    for (output, inputs) in mapping {
        let output = base_out_dir.join(output);
        let inputs = inputs
            .iter()
            .map(|input| base_dir.join(input))
            .collect::<Vec<_>>();

        let run = Command::new("typeshare")
            .args(&inputs)
            .args(["--lang", "typescript", "--output-file"])
            .arg(&output)
            .current_dir(&base_dir)
            .spawn()
            .unwrap()
            .wait()
            .unwrap();
        assert!(
            run.success(),
            "failed to run typeshare for {inputs:?} -> {output:?}: {run:?}"
        );

        let mut content = HEADER.as_bytes().to_vec();

        {
            let mut f = File::open(&output).expect("failed to open output file");
            f.read_to_end(&mut content)
                .expect("failed to read output file");
        }

        {
            let mut f = File::create(&output).expect("failed to create output file");
            f.write_all(content.as_slice())
                .expect("failed to write output file");
        }
    }
}
